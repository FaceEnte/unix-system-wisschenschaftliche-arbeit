% Speaker commands
\setlist[description]{
  font={\sffamily\bfseries},
  labelsep=0pt,
  labelwidth=\transcriptlen,
  leftmargin=\transcriptlen,
}
\newlength{\transcriptlen}
\NewDocumentCommand {\setspeaker} { mo }{%
  \IfNoValueTF{#2}
  {\expandafter\newcommand\csname#1\endcsname{\item[#1:]}}%
  {\expandafter\newcommand\csname#1\endcsname{\item[#2:]}}%
  \IfNoValueTF{#2}
  {\settowidth{\transcriptlen}{#1}}%
  {\settowidth{\transcriptlen}{#2}}%
}

\setspeaker{DS}[Szabo]
\setspeaker{NH}[von Niederhäusern]
\addtolength{\transcriptlen}{1.7em}%

% DOCUMENT
\begin{description}

\DS Ich habe die Fragen ein bisschen aufgeteilt. Das 1. Kapitel wäre jetzt über UNIX an sich. Die erste Frage wäre \glqq Was macht aus Ihrer Sicht UNIX heute noch zu einem relevanten Konzept, beziehungsweise ist es noch relevant und sinnvoll?\grqq

\NH Also grundsätzlich mal ist UNIX ja mehr eine Philosophie als eine technische Implementierung und man hat dann natürlich davon die verschiedenen Instanzen, so wie eben Linux als Klon eines UNIX Systems oder die, die sich halt wirklich quasi auf den Urahnen die sich auf den Ur-UNIX beziehen, wie irgendwelche AIX von IBM ist das glaube ich gewesen. SCO UNIX wo es nochmal gegeben hat. Free BSD vor allem also die ganzen BSD das sind eigentlich die richtigen UNIX Betriebssysteme, oder weil die haben alle noch den ursprünglich Source Code, als es ist nicht klonen oder. Zur Relevanz allgemein vielleicht, je länger, desto mehr natürlich, weil die ganzen Hyperscalers brauchen primär Linux, vielleicht weniger jetzt FreeBSD, halt über die ganzen Containerisierung kommt das ganze Konzept und es hat sich bewährt. Natürlich eine sehr hohe Relevanz, die es vielleicht in der Zwischenzeit mal nicht so gehabt hat in diesen 90er Jahren ist das vielleicht nicht so populär gewesen, es ist mehr richtung Desktop Operating Systems gegangen, wie eben das klassische windows oder ein klassisches macOS und was halt auch ein Hinweis ist wieso ein Konzept an und für sich ohne UI, das je länger, desto mehr relevant wird, oder nach wie vor einfach extrem ein Gewicht hat, ein erfolgsversprechndes Konzept darstellt ist dass ja jetzt Windows seit ja, da bin ich jetzt nicht ganz sicher, vielleicht seit 10 Jahren, eben auch in einer Core Version gibt die ihr also nicht mehr mit UI Tools müsste auseinander setzen oder auseinander schlagen oder sondern wo einfach alles gescriptet werden kann. Also es ist jetzt so eine Art eine Alternativansatz zu Linux. Dass es Windows Core Server Systems gibt, wo man sich mit anderen Befehlen, ähnlich im Prinzip eben bedienen und vor allem im Hinblick darauf auf die Automatisierung und eben, wenn sie irgendeinen Hyperscaler seid oder dann können sie natürlich nicht irgendwie mit einem UI herum hantieren, das ist ja nicht möglich und die irgendwie probieren zu automatisieren das ist das würde dem Konzept völlig widersprechen und darum hat das ganze Konzept eben ein extrem hohes Gewicht, dass es jetzt sicher ein höheres Gewicht bekommen hat, also vor 10-20 Jahren. Und vielleicht auch noch zu macOS, das ist ja im Prinzip auch ein Hybrid zwischen einem richtigen UNIX und so einem Klon, hat sich halt auch dort durchgesetzt. Und alle IOS Geräte und auch alle Android Geräte die basieren eigentlich auf diesem UNIX Konzept, also von dem her, ja \glqq It's here to stay\grqq, es ist absolut eine dominante Philosophie und man will das so und kann das im Prinzip auch nur so über die Schnittstelle, also über Kernel, Tools und auch entsprechend nur so bewerkstelligen. Eben ein reines GUI OS, in dem Sinne, die haben keine Relevanz mehr. Das ist etwa das, was wir dazu spontan in den Sinn käme.
	
\DS Zweite Frage \glqq Die klassischen UNIX Prinzipien wie das Everything is a File, Modularität und so, was denken Sie ist heute bei der Systementwicklung noch relevant und wieso?\grqq

\NH Also Everything is a File ist es sowieso nie gewesen, das ist nur so ein Versuch gewesen, dass man das irgendwie so darstellen kann, aber es gibt x Ausnahmen oder sobald ihr irgendwelche Sockets oder so habt, dann ist es nicht mehr einfach ein File also, dann wird es nachher komplexer, was da sicher relevant, also man kann beides jetzt von diesen 3 Stichworten also kann man sicher Modularität und Portabilität mal in den Vordergrund rücken, wobei ich die Modularität noch fast als relevanter anschauen würde. Weil aus der Modularität gibt es ihnen dann auch jeglichen Vorteil in der Portabilität, weil wenn ihr nicht einfach einen Monolith habt, sondern dann könnt ihr euch das modular eben anpassen erhört dir natürlich auch die Chance, dass es eben portabel ist. Aber von dem her eben ist das sehr eben die Modularität, vor allem ein sehr relevantes Prinzip eben gerade herum in Hinblick darauf auf die ganzen Hyperscaler welche nur gewisse Teile vom Betriebssystem zum Beispiel exponieren, in irgendeinem Dockerumfeld, wo über Sea Groups, also das Ganze Rechte Management auf Kernel Ebene, wo man abstrahieren kann, das ist nur möglich, wenn es modular ist. Obschon man sagen muss jetzt wenn man es noch weiter runter brechen würde, der Linux Kernel in dem Sinne ist nicht ein klassischer modularer Kernel, oder wie man zu der Zeit sagte Minikernel, wo man nachher zur Laufzeit erweitert, sondern ist ein monolithischer Konglomerat, das aber so ein bisschen Ansätze hat, dass man auch zur Laufzeit eben gewissen Treiber nachladen kann. Es ist etwa so ein bisschen vergleichbar, obschon Windows wäre an und für sich ein dynamischer Kernel, aber vom Verhalten her nicht. Also ist es etwa ähnlich vom Konzept her und es hat sich bewährt und eben gerade vor allem im Kontext eben wiederum von diesen hochskalierten Cluster Lösungen oder die es braucht. Und was auch vielleicht relevant ist, im ganzen Scientific Computing also die ganzen super Rechner, also Number crunches die profitieren natürlich eben von genau dieser Modularität oder dass man das sehr gut, einfach eben miteinander verknüpfen kann. Wenn man das eben kontrastiert mit den Main Frames von IBM, da hat man einfach wirklich einen Block, ein Rechner aber der ist so extremst performant, aber einfach gemacht für einen spezifischen Workload. Viele kleine Aufträge, aber jetzt nicht unbedingt eben High Performance und wenn man das UNIX Prinzip dort drauf verwendet, dann hat man vielleicht ein Problem, dann würde die Modularität dann nachher eher zu einem Hindernis werden. Aber sonst grundsätzlich hat sich das Konzept durchgesetzt.
	
\DS Zu diesen Philosophien, die man gemacht hat von UNIX, hat sich im Laufe der Zeit, also im Hinblick von früher zu heute etwas daran geändert oder weiterentwickelt?
	
\NH Geändert ja, leider muss ich fast sagen. Also von Anfang an hat sich halt, und das hat sich jetzt mit Linux natürlich fast verstärkt, die Aufsplittung gegeben. Die erste Aufsplittung  hat es eigentlich gegeben, wo wir System Five und BSD getrennt haben aus lizentechnischen Gründen, aus politischen Gründen, zum Teil auch, was ich im Moment eben nicht so schätze, dass es einfach extremst viele Linux Distributionen gibt und jede funktioniert anders. Es hat andere Tools, weil da ist sich jetzt im Originalunixumfeld mit BSD, oder mit FreeBSD ist man sich der Philosophie eher noch treu geblieben. Also dort hat man die Ursprungsphilosophie eher noch und einen Trend, den ich auch nicht schätze ist, dass man jetzt alles natürlich was eigentlich ein bisschen ein Widerspruch ist zu dem, was ich einleitend gesagt haben, aber alles irgendwie hinter UI verstekcen, also irgendwie GNOME Desktop, KDE Desktop, X Desktop und gar nicht mehr wirklich einfach mit diesen Text Files arbeiten kann, mit diesen Tools arbeiten kann, sondern es ist jetzt fast eine Art ein gegenläufiger Trend eben. Wieder zurück zu den grafischen Tool, aber das ist dem Umstand geschuldet, dass man einfach dem User entgegen kommen will, am End User der vielleicht nicht gerade der UNIX Crack ist und eine Alternative bieten will zu Windows. Ein klassisches Extrembeispiel ist natürlich macOS. Und auch dort habt ihr einen Zoo an verschiedenen Tools, mal sind die auf der User Ebene als Kommando Befehl, nachher gibt es irgendwie ein grafisches Tool, die widersprechen sich oder sind nicht mehr aktuell. Das ist so ein wenig ein Trend, das hat sich verändert eher, jetzt in dem Kontext, zum negativen. Da sehe ich eine gewisse Gefahr. Aber es führt mich gleich zur nächste Frage, es ist nach wie vor eine solide Grundlage, also rein das Konzept. Und das zeigt sich auch sonst hätte isch ja Linux nie so durchgesetzt, sonst hätte man das irgendwann mal als Hobbyprojekt abgeschlossen, ist gut oder der Linus Torvalds hat da 2-3 Jahre Spass daran gehabt und dann hätte man jetzt irgendwie andere Konzepte, aber sonst als Betriebssystem als moderne Basis bietet das nach wie vor eine gute Grundlage.
		
\DS Also denken Sie wenn an jetzt selber ein Betriebssystem machen würde, dass man gut noch UNIX als Grundlage gebrauchen kann?
	
\NH Sicher also entweder man macht eben einen Klon, oder vom Konzept her so wie das Linux ist in Bezug auf UNIX oder man übernimmt gewissen Konzepte, Kernkonzepte ins Betriebssystem, welches von UNIX kommen. Also zum Beispiel Haiku OS oder BI-OS, wo es früher einmal war. Haiku OS das ist auch ein Klon, das sit ein Single User Grafikbasiertes Betriebssystem, hat aber darunter natürlich eine Schnittstelle, welche Posix Compliant ist oder welche von den Befehlen her eben UNIX-OID ist ohne, dass es selber wirklich UNIX ist, auch vom Kernel her nicht. Also eben lassen sich andere natürlich auch sehr gerne inspirieren und was man jetzt auch bisschen gemerkt hat, dass man im Prinzip die Befehle, wo halt mitkommen in einem BSD oder einem UNIX, also Command Line Tools, dass man die auf jedem Betriebssystem, das nicht unbedingt UNIX ist, anbietet. Also viele Befehle, die ähnlich sind unter UNIX gibt es in dieser Form auch unter Windows oder vice versa. Und eben auf die Spitze getrieben worden ist es mit dem ganzen Windows Subsystem for Linux, wo man ja wirklich das emuliert, was auch relative performant ist, ohne dass man eine virtuelle Maschine braucht. Von dem her probiert jetzt Windows so ein bisschen die ganzen Philosophien miteinander zu verheiraten, aber dann sieht man, dass sich das Konzept so eigentlich bewährt hat oder, eben für moderne Betriebssysteme, mit einem Betriebssysteme auf dieser Ebene zu kommunizieren.
	
\DS Jetzt zu Linux selber, wo UNIX-like ist. Wo gibt es dort klare Gemeinsamkeiten und Unterschiede. Und wie konsequent hat es die UNIX Prinzipien umgesetzt?

\NH Ja, also Linux hat es sehr konsequent umgesetzt. Ausser einfach eben auf der Ebene Kernel wahrscheinlich. Dort gibt es unterschiedliche Ansätze, eben ein monolithischer Kernel, das ist technisch versus einen dynamischen Kernel, dort gibt es sicher Unterschiede. Vieles ist natürlich nachimplementiert, also dort unterscheidet sich Linux auf der technischen Ebene von diesen Tools, das ist nichts vom ursprünglichen Sourcecode drin, aus lizentechnsichen Gründen nicht. Das ist vielleicht auch eine Eigenart oder eine fundamentale Unterscheidung von Linux zu UNIX, sie dürfen also nicht die klassischen Source brauchen und wenn man das klassisch lizenziertes UNIX nimmt, dann sind sie in der Regel lizenziert. Aber man findet die klassischen UNIX Betriebssysteme fast gar nicht mehr, also entweder ist es ein FreeBSD, da kann man damit machen, was man will, also man darf das auch kommerzialisieren und bei Linux, dann muss man sich unter Umständen einfach die verwendeten Lizenz im Klaren sein. Darf man das jetzt abschotten was man da gemacht hat als Linux Klon, als Betriebssystem Also da gibt es Lizenzrechtliche Unterschiede. Entweder das UNIX FreeBSD Paradime, wo alles offen ist, \glqq mach damit was du willst\grqq oder komplett \glqq nein du musst es lizenzieren auf der Hardware\grqq für so und so viele Ressourcen, Speicher, RAM, Storage wo wahrscheinlich jetzt bei einem IBM UNIX, also AIX der Fall wäre mehr gibt es fast gar nicht mehr. Und bei Linux, wo man aufpassen muss, wie man es angibt, weil wenn man jetzt irgendwie für eine Root oder für ein embedded Device Linux verwendet und man massgebende Änderungen macht, müsste man die Änderung im Prinzip nachher auch public machen. Dort sind so die verschiedensten Finessen und Unterschiede, wo es zu einem reinen UNIX eben jetzt hat wenn man Linux anschaut. Aber sonst so von den Oberflächen Prinzipien her setzt Linux die Prinzipien eigentlich sehr gut um.
	
\DS macOS ist ja ein UNIX basierendes System.

\NH Genau.

\DS Inwiefern sin die Systemarchitektur und der Alltag von den Nutzern von den UNIX Prinzipien beeinflusst?

\NH Also sagen wir man macOS hat so ein bisschen die Tendenz den User vor dem Computer zu schützen, also von dem her hat man eigentlich das recht gute Aqua GUI, also einfach die ganze Quarz Rendering Engine und ein User muss sich nie mit UNIX auseinandersetzten auf Mac, wenn er das nicht will. Von dem ist es dann sehr konsequent und sehr gut eigentlich gelöst, also am besten im Prinzip. Aber wen man ein Power User ist hat man natürlich eben diese Tools zur Verfügung, allerdings muss man aufpassen, es gibt Unterschiede in der Bedienung zum Teil von den BSD Tools, also von dem richtigen UNIX Tools, wo es unter Mac gibt oder unter den FreeBSD's dieser Welt oder eben dann den Linux Entsprechungen. Die tun sich nicht immer genau gleich verhalten, also zu Teil gibt es andere Optionen, zum Teil sind die Befehle anders, da muss man natürlich immer ein bisschen aufpassen, wenn man häufig hin und her switcht, dass man da sich nicht irgendwie täuschen lässt. Aber sonst für einen normalen Benutzer, für eine normale Benutzerin die nicht mit dem Terminal arbeiten will, dann beeinflussen die UNIX Prinzipien im Prinzip da nicht gross. Wenn man sich technisch damit beschäftigt dann hilft es und das ist ein grosser Pluspunkt aus meiner Sicht eben mit einem Mac Betriebssystem zu arbeiten.

\DS Gibt es auch gewisse Sachen, wo Apple von UNIX Prinzipien herausgenommen hat?

\NH Ja leider. Viele Einstellungen kann man nicht konsequent über die Kommandozeile lösen, da muss man also Tools haben. Und zum Teil gibt es auch irgendwelche Kommandos, die man so nur unter macOS kennt, die gibt es auf keine Art und Weise irgendwo in einem BSD, also überhaupt nicht standardisiert und zum Teil kann man mit verschiedensten Kommandos, von High Level bis Low Level, wo sich aber komplett anders benennen, anders angewendet werden, das Gleiche machen. Also Orthogonalität, die saubere Trennung ist nicht da, man hat immer irgendwie so gewisse Vektoren, wie man es sich vorstellen kann, die etwa in die ähnliche Richtung zeigen, aber nachher trotzdem nicht das Gleiche genau erreichen und das ist manchmal ein bisschen in einem Konflikt und das finde ich schade. Aber eben diese Tendenz, die merkt man auch bei Linux Distributionen, also zum Beispiel bei irgendwie Red Hat oder Ubuntu, da findet man zu Teil Kommandos, die gibt es genau nur auf diesen Plattformen und da gibt es irgendwelche UI Tools die man brauchen muss, weil man es über die Kommandoziele machen würde, würde man alles kaputt machen und vieles ist schon nicht mehr nur ein reinen Textdateien gespeichert, sondern zum Teil irgendwelche Settings Files, also so Portety Lists jetzt unter macOS oder irgendwelche Binärdaten und das ist dort wo jetzt spezifisch macOS der Pfad schon auch verlässt, respektiv die Philosophie ein bisschen ritzt oder verletzt. Da gehe ich gleich weiter zu Windows, also dort ist es ähnlich, dort kommt man einfach von der anderen Seite, mann probiert ein bisschen Linux reinzuholen, aber auch dort dann haben sie ewig den Konflikt zwischen den UI Tools und zum Teil halt noch dort ist jetzt noch extremer, Windows 11 auf Windows 10 Dialoge und über die Kommandozeile kann man gewisse Sachen machen, gewisse dann nicht, dann gibt es 4 Lösungsansätze, je nachdem zum Beispiel die ganze User Management, Access Management das ist ein rissiger hassle unter Windows. Je nach dem auf welcher Ebene der User erstellt worden ist, muss man ein grafisches Tool brauchen oder dann muss man es oder kann man es nur über die Kommandozeile lösen, das ist super mühsam. Eben es ist gerade für viele attraktiv geworden, die ein bisschen frustriert sind von Linux, wo ein Linux Betriebssystem möchten, aber auf den Komfort von Windows nicht verzichten möchten. Vielleicht jetzt Leute, die sich mehr in einem Web Developer Umfeld bewegen, die halt darauf angewiesen sind, weil Windows die weitverbreitete Plattform ist, dass sie es direkt darauf test können, aber trotzdem irgendwelche Treiber brauchen, irgendwelche Hardware brauchen, aber eine Flexibilität von einem Linux möchten. Das ist natürlich das Windows Subsystem schon sehr eine gute Alternative muss ich sagen. Vor allem jetzt die zweite version, bin ich auch recht ein Fan davon. Und dort sehe ich schon, dass sich Windows auch ein bisschen dieser Gruppe von Special Need Users annähert, durch das Subsystem. Von dem her geht das sicher in die richtige Richtung, auch wenn es dann Richtung Docker geht, obwohl das ist eine Krücke natürlich unter Mac und Windows das sind nicht wirklich Dockerfähige Systeme, weil das baut ja auf einem native Linux Kernel auf, aber trotzdem Docker for Desktop als Hilfsapplikation wären dort auch noch so eine Alternative, allerdings nicht so performant wie eben jetzt ein Windows Subsystem. Aber diese Zielgruppe sehe ich dort schon von Profi User, die auf den Komfort von Windows nicht verzichten möchten, weil es gibt einfach gute Tools unter Windows und es ist einfach die Plattform, die dominant ist mit ja, vielleicht sind es mittlerweile nur noch 95\% anstatt 98\%. Aber es ist halt nach wie vor extremst relevant und nachher als zweites dominantes Betriebssystem ist Mac vielleicht irgendwie 15\%, wobei das würde dann nicht gehen wenn man auf 100 aufrundet, und Linux die dann ganz einen kleinen Teil ausmacht.

\DS Jetzt noch eine Zwischenfrage, finden Sie es gut, dass Windows auf Platz 1 ist, von den Nutzer Betriebssystem oder würden Sie persönlich sagen, dass jetzt macOS oder Linux besser wäre?

\NH Nein ich habe nicht das Gefühl, dass das ein Problem ist. Es ist halt eine historisches, politisches Problem, dass Windows so dominant ist, wäre es nicht Windows wäre es ein anderes Betriebssystem und dann würde man das halt einfach als Target ins Auge fassen sowohl politisch und technisch, darum gibt es die meisten Angriffe auf Windows. Deshalb kritisieren die meisten auch Windows. Ja, es ist nicht Open Source ok, macOS ist auch nicht Open Source letzte Konsequenz. Linux übrigens auch nicht, viele Tools die gibt es nicht in Source Form, also von dem her ist es jetzt halt einfach so wie es ist, wird sich mittelfristig auch nicht ändern, bis man dann natürlich unter Umständen einfach mal das Konzept vom klassischen Desktop Computer nicht mehr braucht. Wenn dann irgendwelche andere Paradigmen kommen, eben jetzt irgendwie über Smartphone oder über irgendwelche ja Brain Implants oder so, wobei da kann ich mich nicht zu einer Prognose konkret äussern jetzt ist es einfach mal so wie es ist und das schadet sicher Windows nicht, eben dass es so bisschen die Embrace Philosophie hat, die Linux Komponenten aufgreift, jetzt einfach rein auf der Ebene vom Benutzer. In the cloud dort sieht es ein bisschen anders aus. Dort gibt es eigentlich nur Linux, dort gibt es sehr wenige Windows Systeme. Von dem her balanciert sich das ein bisschen aus.

\DS Frage 11 haben Sie eigentlich schon beantwortet. Die Frage 12 wo sind Ihrer Meinung nach grundlegende Unterschiede von Architektur, Design und Nutzerphilosophie von diesen 3 Betriebssysteme untereinander von Linux, macOS und Windows?

\NH Ja eben Architektur, da habe ich mich schon dazu geäussert, also da ist man dann irgendwo auf der Eben vom Kernel, Micro versus Monlithic Kernels oder Hybrid Kernels, so wie es unter Mac ist, aber sonst eben Design und Nutzer Philosophie, eben es verschmilz alles. Als auch wenn der Trend auf Linux sitzt, möglich vieles grafisch anzubieten, ich meine das spricht Bände und von dem her das nimmt sich nicht mehr viel, man fährt mit der Maus über irgendwelche Masken, klickt irgendwelche Buttons oder Touchscreen ob es jetzt ein Windows Tablet ist oder ein IOS Phone oder ein Android Tablet oder wie auch immer, grundsätzlich das ist alles so ähnlich, man kann die Paradigmen nicht jedes mal neu erfinden. Es ist schon seit 30 Jahren so, es hat sich bewährt und das bleibt jetzt einmal so, bis man dann eventuell mal so ein Brain Computer hat. Aber sonst, im Moment denke ich bleibt das mal sehr sehr ähnlich.

\DS Jetzt im Bereich Softwareentwicklung, bevor man jetzt diese UNIX Philosophie festgelegt hat, hat sich nachher in der Softwareentwicklung etwas geändert?

\NH Ja ich würden doch schon sagen, also vorher hat man sehr stark Main Frame fokussiert gearbeitet, mit irgendwelchen, wie soll ich das sagen? Nicht sehr flexiblen Programmiersprachen, also irgendwelche Cobalts oder irgendwelche Fortrans, Algols dieser Welt, in den 50er 60er Jahren. Vorher war es noch schlimmer, dann hat man einfach genau für diese Maschinen den Programmcode mehr oder weniger in Hardware gegossen und was halt die UNIX Philosophie über die Pipes eingeführt hat ist so das funktionale, also eben auch dank der Modularität, dass man nicht mehr einfach sehr statisch programmiert, obschon C ja eher dem ein bisschen widerspricht, also das C als die Programmiersprache, die eigentlich der Siegeszug von UNIX oder ist es umgekehrt gewesen? Es ist immer so schwierig oder eine Hähne Ei Problematik. Erst ermöglicht hat weil man das UNIX dank C auf verschiedene Plattformen Portieren konnte, weil es so eine einfache Programmiersprache ist. Aber denken wir jetzt ein Level weiter oben, also über diese Kommandotools, wo wir Shell brauchen, Sie kennen es ja vom Kurs oder wo man mit Pipes miteinander eben arbeiten kann. Das ist schon ein sehr modernes Konzept, das man jetzt eigentlich eher so erfährt, wenn man jetzt so modernere Programmiersprachen anschaut, die fangen jetzt alle an, mit der eben sequence base Programmierung an, also mit den Ranges in C++, mit Link in C\# oder .NET, mit den Streams in Java, das ist alles oder PowerShell, ganz extrem, das ist alles irgendwie auf dieser Philosophie basierend, dass man so funktional arbeitet, dass man alles in einer Sequenz hat, anstatt dass man so geschachtelte Funktionsaufrufe hat, wo man im Prinzip von innen nach aussen denken muss, das macht es extrem unergonomisch. Jetzt kann man einfach wie man Test liest, von links nach rechts kann man sich irgendwelche Befehle aneinander Reihen und man sieht sofort was da passiert. Das denke ich ist schon so eine Lasting Legacy oder ebene ein Tool Design, das sich absolut durchgesetzt hat. Das muss man ganz klar sagen. Aber eben ich muss noch dazusagen, das sind einfach meine Ansichten oder vielleicht jemand, der jetzt bei Microsoft arbeitet hat ja da irgendwie einen guten Einwand, wo man sagen kann \glqq OK ja doch das Bärenpunkt\grqq, aber jetzt von mir aus gesehen eben denke ich das es wirklich ein relevanter Faktor wo da UNIX in die ganze Betriebssystemlandschaft eingeführt hat.

\DS Denken Sie, dass die UNIX Prinzipien so in den nächsten Jahren oder Jahrzehnten in den Betriebssystemen immer noch vorkommen oder dass man bis dahin irgend etwas anderes wieder festlegt?

\NH Ja, irgendwann ist man ausgeschossen mit den Konzepten. Also von dem her man hat fast keine andere Wahl als das so zu  machen, ja vielleicht irgendwelche Real Time Operating Systems, die ganz extreme Constraints, also Einschränkungen haben. Der braucht vielleicht jetzt nicht ein Linux Kernel oder einen UNIX Kernel, da hat man mehr so ein RTOS Kernel, das sind aber, aber schlussendlich probiert man das Konzept zu wiederholen, weil das hat sich bewährt. Also darum sehe ich jetzt nicht, zumindest auf der technischen Ebene, da jetzt noch extreme Revolution passiert. Und ein Quantencomputer, der braucht kein Betriebssystem, also das sind Optimierungsmaschinen, das ist völlig etwas anderes. Also ich kann jetzt nicht mit dem Argument kommen \glqq Ja wie sieht jetzt aus, wenn man dann mal eben die Quantencomputer hat?\grqq Auch der wird Schnittstellen anbieten, die sich genau so verhalten werden, weil es sich einfach bewährt hat über die Zeit. Aber vielleicht mehr so, dass das Halt weg abstrahiert wird, dass man als User, als technischer Benutzer sich gar nicht mehr ganz im klaren ist, und es ist auch nicht mehr relevant was darunter passiert, also under the hood, es kann im Prinzip dann nachher wie egal sein. Aber jetzt einfach, wen ich ein Ingenieur wäre und ein Betriebssystem entwickeln würde, würde ich wohl ähnliche Ansätze verwenden halt auch, weil es sich bewehrt hat. Und auch verschiedene Hardware, welche es jetzt gibt, wie ARM, Risk W, also Risk 5, die brauchen alle irgendwelche Linuxoiden Betriebssysteme, weil die sich auch schnell rapportieren lassen. Da warten Sie nicht bis Microsoft sich dazu durch gerungen hat, eben dort irgendwie Windows drauf laufen lassen zu können.

\DS Passen zu der Antwort gehe ich schnell zur letzte Frage, denken Sie in dem Fall dass UNIX Philosophie, in den nächsten Jahren vielleicht stärker umgesetzt werden als sie jetzt sind?
 
\NH Ja ich denke der Trend aktuell ist schon in diese Richtung, definitiv. Also eben, wenn man das ganze Cloudcomputing, Cloud Infrastructure, Hyperscaling anschaut, sieht man diesen Trend ganz klar und auch im ganzen Machine Learning Umfeld, weil es sind schlussendlich auch Hyperscaler, da braucht man einfach ein Linux und mit Windows ist das sehr sehr schwer umzusetzen, weil die Iterationszeiten, für etwas neues zu entwickeln bei Windows zu hoch ist, weil es ein komplexes grafische System ist, mit den ganzen Überbau, da probiert man das trotzdem zu Shoehorne, also rein zu drücken, dass man das dann nachher sauber machen kann, bringt es aber nie wirklich ganz hin. Also darum, die UNIX Prinzipien, ob konkret oder abstrakt, über die Modularität eben von irgendwelchen Containern, Kubernetes oder so, das wird sich so sicher stärken. Und man hat auch verschiedene Abstraktionslevel und das ermöglicht eben UNIX sehr gut, dass man sich in diesen verschiedenen oder auf diesen verschiedenen Abstraktionslevels ohne viel Reibung bewegen kann. Also im Prinzip ganze Tech Stack hoch und runter gehen kann.

\DS Ja, die Frage 15 habt ihr ja auch schon beantwortet mit diesen Containersierung.

\NH Genau.

\DS Das wär's eigentlich auch gewesen.

\NH Ja, und eben sonst, falls Ihnen jetzt dann beim Zusammenfassen oder beim normalen Auswerten eine Frage kommt oder wenn es eine Frage gibt oder noch eine Klärung braucht oder so, dann schreiben Sie mir einfach und nachher probieren wir  diese noch mal besser zu beantworten oder vielleicht im Nachgang kommt mir dann etwas noch in den Sinn, da kann ich Ihnen das schon noch bekannt geben, oder würde sie Ihnen das auch noch kommunizieren.

\DS Ja merci.
	
\end{description}